<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><title> Python 获取控制台输出二三事 · xiaopc</title><meta name="description" content="Python 获取控制台输出二三事 - xiaopc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://xiaopc.org/atom.xml" title="xiaopc"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="xiaopc" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">home</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">archives</a></li><li class="nav-list-item"><a class="nav-list-link" href="/links/" target="_self">links</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://xpc.im/" target="_blank">about</a></li><li class="nav-list-item"><a class="nav-list-link" href="/blog-en/" target="_self">en</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Python 获取控制台输出二三事</h1><div class="post-info">2019年2月20日 · <a href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></div><div class="post-content"><p>事情从这里开始。</p>
<p>需要用 Python 调用 <a target="_blank" rel="noopener" href="https://github.com/iawia002/annie">annie</a> 并获取下载进度。</p>
<span id="more"></span>
<p>这还不简单吗? 直接就写出了代码 1：</p>
<h2 id="readline">readline</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    shell_cmd = <span class="string">&#x27;./annie -i av42398581&#x27;</span></span><br><span class="line">    cmd = shlex.split(shell_cmd)</span><br><span class="line"></span><br><span class="line">    p = subprocess.Popen(cmd, shell=<span class="literal">False</span>, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line">    <span class="keyword">while</span> p.poll() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;output: %s&quot;</span> % p.stdout.readline())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Subprogram exit with code %d&#x27;</span> % p.returncode )</span><br></pre></td></tr></table></figure>
<p>然而结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output: b&#x27;\n&#x27;</span><br><span class="line">Subprogram exit with code 0</span><br></pre></td></tr></table></figure>
<p>但其他命令都很正常，比如 wget, ping。</p>
<p>然后发现 annie 这里是多行一起输出再刷新缓冲区的，然后就改成了代码 2：</p>
<h2 id="iter">iter</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    shell_cmd = <span class="string">&#x27;./annie -i av42472579&#x27;</span></span><br><span class="line">    cmd = shlex.split(shell_cmd)</span><br><span class="line"></span><br><span class="line">    p = subprocess.Popen(cmd, shell=<span class="literal">False</span>, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)</span><br><span class="line">    <span class="keyword">while</span> p.poll() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">iter</span>(p.stdout.readline, <span class="string">b&#x27;&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;output: %s&quot;</span> % line.rstrip().decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p><code>iter()</code> 函数用来生成迭代器，传入有第二个参数就表示第一个参数是可调用的。</p>
<p>通过这个生成的迭代器持续执行 <code>readline()</code> 直至没有输出。</p>
<p>现在输出看起来没问题了，吧？</p>
<p>且慢。annie 的 <code>-i</code> 参数只解析不下载，那去掉 <code>-i</code> 参数呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">output:  </span><br><span class="line">output:  Site:      哔哩哔哩 bilibili.com </span><br><span class="line">output:  Title:     【官方双语】 一万刀的CPU 能修好吗？#linus谈科技</span><br><span class="line">output:  Type:      video</span><br><span class="line">output:  Streams:   # All available quality</span><br><span class="line">output:      [80]  -------------------</span><br><span class="line">output:      Quality:         高清 1080P</span><br><span class="line">output:      Size:            204.75 MiB (214691421 Bytes) </span><br><span class="line">output:      # download with: annie -f 80 ...</span><br><span class="line">output:</span><br></pre></td></tr></table></figure>
<p>然后就卡住了。</p>
<p>发现 annie 的进度条是用 <code>\r</code> 实现的，而 <code>readline()</code> 是按 <code>\n</code> 分割的。</p>
<p>但是除非下载完成，annie 不会输出 <code>\n</code>... 所以 <code>readline()</code> 会一直读输出流的数据。</p>
<p>那就考虑用 <code>read()</code> 实现自定义 <code>readline()</code>?</p>
<p>于是就有了代码 3：</p>
<h2 id="yield">yield</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">customized_readline</span>(<span class="params">stream, delimiter, buffersize=<span class="number">1</span></span>):</span><br><span class="line">    lines = [<span class="string">b&#x27;&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> <span class="built_in">iter</span>(<span class="keyword">lambda</span>: stream.read(buffersize), <span class="string">b&#x27;&#x27;</span>):</span><br><span class="line">        lines = re.split(delimiter, lines[-<span class="number">1</span>] + data)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines[:-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">yield</span> line</span><br><span class="line">    <span class="keyword">yield</span> lines[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    shell_cmd = <span class="string">&#x27;./annie av42472579&#x27;</span></span><br><span class="line">    cmd = shlex.split(shell_cmd)</span><br><span class="line"></span><br><span class="line">    p = subprocess.Popen(cmd, shell=<span class="literal">False</span>, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, bufsize=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> p.poll() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> customized_readline(p.stdout, <span class="string">b&#x27;\n|\r&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;output: %s&quot;</span> % line.decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>这里涉及到几个点：</p>
<ol type="1">
<li><p>因为 <code>read()</code> 要加大小作为参数，如果直接 <code>stream.read(buffersize)</code> 就变成函数求值然后传参了。 所以这里需要用 lambda 表达式，返回 <code>callable</code> 对象。（使用偏函数也可 <code>from functools import partial</code>）</p></li>
<li><p>这里用 <code>re.split()</code> 是因为要匹配多种分隔符，如果只用一种就不需 <code>re</code>。</p></li>
<li><p><code>customized_readline</code> 返回的是个生成器。简单来讲，每次迭代调用时都会从上次 <code>yield</code> 后继续。 <code>lines</code> 存储着没有一次输出的剩余行。</p></li>
</ol>
<p>但是呢，如果 <code>delimiter</code> 和 <code>buffersize</code> 设置不好的话，可能会出现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;b.py&quot;, line 20, in &lt;module&gt;</span><br><span class="line">    print(&quot;output: %s&quot; % line.decode(&#x27;utf8&#x27;))</span><br><span class="line">UnicodeDecodeError: &#x27;utf-8&#x27; codec can&#x27;t decode bytes in position 98-99: unexpected end of data</span><br></pre></td></tr></table></figure>
<p>很明显是从 <code>bytes</code> 解码成 UTF-8 时出错了。</p>
<p>为什么呢？UTF-8 是一种变长编码，ASCII 字符是 1 字节编码，而汉字是 3 字节编码，就出现了被截断的汉字。</p>
<p>那怎么办呢？干脆自己做 decode 吧，于是就有了代码 4：</p>
<h2 id="iterdecode">iterdecode</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> codecs <span class="keyword">import</span> iterdecode</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iter_unicode_chunks</span>(<span class="params">byte_stream, encoding=<span class="string">&#x27;utf-8&#x27;</span></span>):</span><br><span class="line">    binary_chunks = <span class="built_in">iter</span>(<span class="keyword">lambda</span>: byte_stream.read(<span class="number">1</span>), <span class="string">b&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> unicode_chunk <span class="keyword">in</span> iterdecode(binary_chunks, encoding):</span><br><span class="line">        <span class="keyword">yield</span> unicode_chunk</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">customized_readline</span>(<span class="params">iter_chunk_stream, delimiter</span>):</span><br><span class="line">    lines = [<span class="string">&#x27;&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> iter_chunk_stream:</span><br><span class="line">        lines = re.split(delimiter, lines[-<span class="number">1</span>] + data)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines[:-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">yield</span> line</span><br><span class="line">    <span class="keyword">yield</span> lines[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    shell_cmd = <span class="string">&#x27;./annie av42472579&#x27;</span></span><br><span class="line">    cmd = shlex.split(shell_cmd)</span><br><span class="line"></span><br><span class="line">    p = subprocess.Popen(cmd, shell=<span class="literal">False</span>, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, bufsize=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> p.poll() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> customized_readline(iter_unicode_chunks(p.stdout), <span class="string">&#x27;\r|\n&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;output: %s&quot;</span> % line)</span><br></pre></td></tr></table></figure>
<p>这里用了 <code>codecs.iterdecode</code>，它也是生成器，每次喂进去一个 byte，直到能被解析就 yield 一个编码字符。</p>
<p>看起来解决了？</p>
<p>当重新看 subprocess 的文档时，突然发现了...</p>
<h2 id="universal_newlines">universal_newlines</h2>
<p>subprocess.Popen 有个参数 <code>universal_newlines</code>。</p>
<p>该参数为 True 时 <code>stdout</code> 和 <code>stderr</code> 会被视为文本，而且会将所有换行符转为 <code>\n</code>。</p>
<p>转了一大圈然后回到原点...所以最终代码 5：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    shell_cmd = <span class="string">&#x27;./annie av42398581&#x27;</span></span><br><span class="line">    cmd = shlex.split(shell_cmd)</span><br><span class="line"></span><br><span class="line">    p = subprocess.Popen(cmd, shell=<span class="literal">False</span>, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">while</span> p.poll() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">iter</span>(p.stdout.readline, <span class="string">b&#x27;&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;output: %s&quot;</span> % line.rstrip())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Subprogram exit with code %d&#x27;</span> % p.returncode )</span><br></pre></td></tr></table></figure>
<p>完。</p>
<hr />
<p>本文参考了：</p>
<p>[1] Python获取命令实时输出-原样彩色输出并返回输出结果 https://blog.csdn.net/tp7309/article/details/79392313</p>
<p>[2] Using readline with a new delimiter of line ? https://bytes.com/topic/python/answers/26125-using-readline-new-delimiter-line</p>
<p>[3] UTF-8 - 维基百科，自由的百科全书 https://zh.wikipedia.org/wiki/UTF-8</p>
<p>[4] Working with unicode streams in Python | And then it crashed https://blog.etianen.com/blog/2013/10/05/python-unicode-streams/</p>
<p>[5] Python模块整理(三)：子进程模块subprocess http://blog.51cto.com/ipseek/807513</p>
</div><div class="post-footer"><p class="license">本文以「<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-sa/4.0">知识共享 署名—相同方式共享（CC BY-SA 4.0）</a>」发布。<br><br>
允许复制、转贴、演绎本文，<br>
惟需注明本文地址，<br>
并遵循相同许可协议。<br></p><div class="like"><img class="like-qrcode" src="/wechat_like.png" alt="like qrcode"><img class="avatar" src="/avatar.jpg"></div></div></article></div></main><footer><div class="paginator"><a class="prev" href="/2019/03/11/flarum-0-1-0-beta8-1-%E9%AD%94%E6%94%B9%E4%B9%8B%E9%82%AE%E4%BB%B6/">上一篇</a><a class="next" href="/2019/02/15/flarum-0-1-0-beta8-1-%E4%B8%AD%E6%96%87%E5%8C%96/">下一篇</a></div><div class="copyright"><p>&copy; 2023 <a href="https://xiaopc.org">xiaopc</a>, <a href="https://hexo.io/" target="_blank">hexo</a> & <a href="https://github.com/xiaopc/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdnjs.loli.net/ajax/libs/mathjax/2.7.2-rc/MathJax.js?config=TeX-AMS-MML_HTMLorMML" crossorigin="anonymous"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KNHBVTCZSN"></script><script>window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', "G-KNHBVTCZSN");</script></body></html>